# -*- coding: utf-8 -*-
"""GTestD.ipynb

Automatically generated by Colab.

"""

pip install openai

pip install pytesseract

pip install pyTelegramBotAPI six

pip install pdfminer.six

pip install --upgrade openai

# Установка пути к Tesseract для Google Colab
!apt-get update
!apt-get install -y tesseract-ocr

import telebot
import openai
from openai import OpenAI
from telebot.types import Message, Document
import pytesseract
from pdfminer.high_level import extract_text
from PIL import Image
import io
import re

# Установка API токенов
TELEGRAM_BOT_TOKEN = 'your token'
OPENAI_API_KEY = 'your api key'


key = OPENAI_API_KEY

client = OpenAI(
    api_key=key,
)

bot = telebot.TeleBot(TELEGRAM_BOT_TOKEN)
openai.api_key = OPENAI_API_KEY

# Словарь для хранения истории сообщений и документов каждого пользователя
user_data = {}

# Обработчик для команды /start
@bot.message_handler(commands=['start'])
def send_welcome(message: Message):
    user_id = message.chat.id
    user_data[user_id] = {'messages': [], 'documents': []}  # Инициализируем данные пользователя
    bot.reply_to(message, "Привет! Меня зовут Дарья, я ИИ ассистент, созданный для помощи по вопросам здорового образа жизни и медицины. Просто отправьте Ваш вопрос или документ, и я постараюсь Вам помочь.")

# Обработчик сообщений
@bot.message_handler(content_types=['text'])
def handle_text(message: Message):
    user_id = message.chat.id
    user_message = message.text

    # Сохраняем сообщение пользователя в историю
    if user_id not in user_data:
        user_data[user_id] = {'messages': [], 'documents': []}
    user_data[user_id]['messages'].append({"role": "user", "content": user_message})

    # Добавляем системное сообщение с описанием бота
    if not any(msg['role'] == 'system' for msg in user_data[user_id]['messages']):
        user_data[user_id]['messages'].insert(0, {"role": "system", "content": "Привет! Меня зовут Дарья, я ИИ ассистент, созданный для помощи по вопросам здорового образа жизни и медицины."})

    # Получаем ответ от ChatGPT с учетом истории сообщений
    response = get_chatgpt_response(user_id)
    user_data[user_id]['messages'].append({"role": "assistant", "content": response})
    bot.reply_to(message, response)

# Обработчик документов (PDF, JPEG, PNG, JPG)
@bot.message_handler(content_types=['document', 'photo'])
def handle_document(message: Message):
    user_id = message.chat.id
    try:
        if message.content_type == 'document':
            file_id = message.document.file_id
            file_name = message.document.file_name
        elif message.content_type == 'photo':
            file_id = message.photo[-1].file_id  # Получаем последнюю версию фото (наибольшее разрешение)
            file_name = f"photo_{file_id}.jpg"
        else:
            bot.reply_to(message, "Извините, я могу обрабатывать только документы в формате PDF, JPEG, PNG или JPG.")
            return

        file_info = bot.get_file(file_id)
        downloaded_file = bot.download_file(file_info.file_path)

        # Сохранение файла локально
        with open(file_name, 'wb') as new_file:
            new_file.write(downloaded_file)

        # Извлечение текста из документа
        if file_name.endswith('.pdf'):
            text = extract_text(file_name)
        elif file_name.endswith(('.jpg', '.jpeg', '.png', '.JPG')):
            image = Image.open(io.BytesIO(downloaded_file))
            text = pytesseract.image_to_string(image)
        else:
            bot.reply_to(message, "Извините, я могу обрабатывать только документы в формате PDF, JPEG, PNG или JPG.")
            return

        # Удаление ФИО из текста
        text = remove_personal_info(text)

        if text.strip():
            # Сохраняем документ и извлеченный текст в данные пользователя
            if user_id not in user_data:
                user_data[user_id] = {'messages': [], 'documents': []}
            user_data[user_id]['documents'].append({'file_name': file_name, 'content': text})
            user_data[user_id]['messages'].append({"role": "user", "content": text})

            # Добавляем системное сообщение с описанием бота, если его нет в истории
            if not any(msg['role'] == 'system' for msg in user_data[user_id]['messages']):
                user_data[user_id]['messages'].insert(0, {"role": "system", "content": "Привет! Меня зовут Дарья, я ИИ ассистент, созданный для помощи по вопросам здорового образа жизни и медицины."})

            response = get_chatgpt_response(user_id)
            user_data[user_id]['messages'].append({"role": "assistant", "content": response})
            bot.reply_to(message, response)
        else:
            bot.reply_to(message, "Не удалось извлечь текст из документа. Пожалуйста, убедитесь, что документ содержит читаемый текст.")

    except Exception as e:
        bot.reply_to(message, f"Извините, произошла ошибка при обработке документа: {str(e)}")

# Функция для удаления ФИО из текста
def remove_personal_info(text):
    # Регулярное выражение для поиска ФИО (предполагаем, что это три слова с заглавной буквы или полностью заглавные)
    return re.sub(r'\b[А-ЯЁ][а-яё]+\s[А-ЯЁ][а-яё]+\s[А-ЯЁ][а-яё]+\b|\b[А-ЯЁ]+\s[А-ЯЁ]+\s[А-ЯЁ]+\b', '', text)

# Функция для получения ответа от ChatGPT
def get_chatgpt_response(user_id):
    try:
        messages = user_data[user_id]['messages']
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            top_p=0.5,
            max_tokens=500,
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        return f"Извините, произошла ошибка при запросе к API ChatGPT: {str(e)}"

# Запуск бота
if __name__ == '__main__':
    print("Бот запущен...")
    bot.polling(none_stop=True)
